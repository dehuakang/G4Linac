

//***** Generated by Geant4 Geometry Editor at  Sun Dec 05 14:13:21 CET 2010 *****
//********************************************************************************



//------Fichier d'entete--------------- 
#include "volumeConstruction.hh"
#include "G4DrawVoxels.hh"
#include "G4UnitsTable.hh"
#include "G4NistManager.hh"
#include "G4VUserDetectorConstruction.hh"
#include "G4TransportationManager.hh"
#include "G4RegionStore.hh"
#include "globals.hh"
#include "G4Material.hh"
#include "G4MaterialTable.hh"
#include "G4Element.hh"
#include "G4ElementTable.hh"
#include "G4Box.hh"
#include "G4Region.hh"
#include "G4LogicalVolume.hh"
#include "G4ThreeVector.hh"
#include "G4PVPlacement.hh"
#include "G4PVReplica.hh"
#include "G4SDManager.hh"
#include "G4VisAttributes.hh"
#include "G4Colour.hh"
#include "G4Tubs.hh"
#include "G4Cons.hh"
#include "G4Paraboloid.hh"
#include "PhantomROGeometry.hh"
#include "G4SubtractionSolid.hh"
#include "G4UnionSolid.hh"
#include "G4IntersectionSolid.hh"
#include "PhantomSD.hh"
#include "G4Region.hh"
#include "G4RegionStore.hh"
#include "G4ProductionCuts.hh"
#include "G4ProductionCutsTable.hh"
#include "G4UserLimits.hh"
volumeConstruction::volumeConstruction(G4String &SDName)
//Initialisation des variables :Solids ,Logiques,Physiques,Regions.
: pMere(0),phantomSD(0), Phantom(0), PhantomLog(0), PhantomPhys(0),vacum(0),LoGicWater(0),pLoGicWater(0)


{



  sensitiveDetectorName = SDName;



  }
// ==================================================================================
//  DESCRECTOR METHOD OF THE CLASS VOLUMECONSTRUCTION
// ==================================================================================

volumeConstruction::~volumeConstruction()
{; }
// ==================================================================================
//  THIS METHOD SET-UP VISUALIZATION ATTRIBUT FOR EACH ELEMENT OF ACCELERATOR
// ==================================================================================

 G4VisAttributes *volumeConstruction::AttributName(const G4String attributName)
{
G4VisAttributes * attribut=new G4VisAttributes();

if (attributName=="phantom_attribut")
	{
  G4VisAttributes * phantom_attribut=  new G4VisAttributes( G4Colour(127/255. ,0/255. ,255/255. )); 
 attribut=phantom_attribut;
return attribut;
}
if (attributName=="water_attribut")
	{
  G4VisAttributes * water_attribut=  new G4VisAttributes( G4Colour(0/255. ,0/255. ,255/255. )); 
 attribut=water_attribut;
return attribut;
}

return attribut;
}

// ==================================================================================
//  THIS METHOD SET-UP MATERIAL FOR EACH ELEMENT OF ACCELERATOR
// ==================================================================================


G4Material * volumeConstruction::MaterialName(const G4String materialName)
{
G4double z, a, density;
 G4String name, symbol;
 G4int ncomponents;
G4double fractionmass;
G4Material * material=0;

	
	//--------- les Elements . -----------------------------------------------

  G4Element* elementH = new G4Element( "Hydrogen", "H", 1. , 1.00794*g/mole );
  G4Element* elementC = new G4Element( "Carbon", "C", 6. , 12.01*g/mole );
  G4Element* elementN = new G4Element( "Nitrogen", "N", 7. , 14.00674*g/mole );
  G4Element* elementO = new G4Element( "Oxygen", "O", 8. , 15.9994*g/mole );
  //G4Element* elementMg = new G4Element( "Magnesium", "Mg", 12. , 24.305*g/mole );
  G4Element* elementSi = new G4Element( "Silicon", "Si", 14. , 28.0855*g/mole );
  //G4Element* elementP = new G4Element( "Phosphorus", "P", 15. , 30.973762*g/mole );
 // G4Element* elementCl = new G4Element( "Chlorine", "Cl", 17. , 35.4527*g/mole );
  G4Element* elementAr = new G4Element( "Argon", "Ar", 18. , 39.948*g/mole );
  //G4Element* elementCa = new G4Element( "Calcium", "Ca", 20. , 40.078*g/mole );
  G4Element* elementCr = new G4Element( "Chromium", "Cr", 24. , 51.9961*g/mole );
  G4Element* elementMn = new G4Element( "Maganese", "Mn", 25. , 54.93805*g/mole );
  G4Element* elementFe = new G4Element( "Fer", "Fe", 26. , 55.85*g/mole );
  G4Element* elementNi = new G4Element( "Nickel", "Ni", 28. , 58.69*g/mole );
  G4Element* elementCu = new G4Element( "Copper", "Cu", 29. , 63.546*g/mole );
  G4Element* elementW = new G4Element( "W", "W", 74. , 183.85*g/mole );

	if (materialName=="air")
	{
  G4Material* air = new G4Material("air",density=0.0012*g/cm3,  ncomponents=4);
  air->AddElement( elementC, 0.0124 *perCent);
  air->AddElement( elementN, 75.527 *perCent);
  air->AddElement( elementO, 23.178 *perCent);
  air->AddElement( elementAr, 1.2827 *perCent);
  material=air;	
}
	
else if (materialName=="m15")
	{
		G4Material* m15 = new G4Material("m15",  density=0.9982*g/cm3,ncomponents= 2);
  m15->AddElement( elementH, 11.11*perCent);
  m15->AddElement( elementO, 88.89*perCent );
		 material=m15;
	}
else if (materialName=="m14")
	{
		G4Material* m14 = new G4Material(name="m14",density=1.19*g/cm3, ncomponents=3);
  m14->AddElement(elementH,8*perCent);
  m14->AddElement(elementC,60*perCent);
  m14->AddElement(elementO,32*perCent);
  
		 material=m14;
	}
	

	return material;
}
G4VPhysicalVolume* volumeConstruction::Construct( )
{

// ==================================================================================
//  THIS METHOD SET-UP THE WORLD VOLUME
// ==================================================================================


G4Material *air=this->MaterialName("air");
//G4VisAttributes *Invisible_attribut=this->AttributName("Invisible_attribut");

   G4Box *solidvolMere= new G4Box("solidvolMere",25*cm, 25*cm, 100*cm );
  G4LogicalVolume * volMere = new G4LogicalVolume(solidvolMere, 	 //its solid
			 air, 		 //its material
			"volMere" ,		 //its name
			 0,0,0);
//cet volume est invisible
 volMere ->SetVisAttributes(G4VisAttributes::GetInvisible());
   
G4RotationMatrix rotMatrixpMere;   // unit rotation matrix
G4double anglepMere = 0.0*deg;   // rotational angle
rotMatrixpMere.rotateX(anglepMere);  // rot matrix

pMere= new G4PVPlacement(G4Transform3D(rotMatrixpMere,	//rotation 
		 G4ThreeVector(0.0*mm, 0.0*mm, 0.0*mm)),
		 "pMere",   //its name  (2nd constructor)
		 volMere,         //its logical volume 
		 NULL,              //its mother volume 
		 false,                 //no boolean operation 
	
	 0);                       //


 //Definition du fontome 
G4VisAttributes *m15_attribut=this->AttributName("m15_attribut");
G4Material *m15=this->MaterialName("m15");
G4VisAttributes *m14_attribut=this->AttributName("m14_attribut");
G4Material *m14=this->MaterialName("m14");

G4double Water_DemiX =20.0*cm;
G4double Water_DemiY =20.0*cm;
G4double Water_DemiZ =20.0*cm ;

G4Box *SolidWater= new G4Box("SolidWater",Water_DemiX , Water_DemiY,Water_DemiZ );

G4double FontomeA_DemiX =21.5*cm;
G4double FontomeA_DemiY =21.5*cm;
G4double FontomeA_DemiZ =21.25*cm ;

G4Box *solidFontomeA= new G4Box("solidFontomeA",FontomeA_DemiX , FontomeA_DemiY,FontomeA_DemiZ );

G4Box *solidFontomeB= new G4Box("solidFontomeB",Water_DemiX ,  Water_DemiY,FontomeA_DemiZ);
G4ThreeVector  decalage_z(0*cm,0,2.5*cm);
G4RotationMatrix* Rotation_z = new G4RotationMatrix;
Rotation_z->rotateX(0.*deg);
G4SubtractionSolid* solidFontome = new G4SubtractionSolid ("solidFontome",solidFontomeA,solidFontomeB,Rotation_z,decalage_z);
LoGicWater = new G4LogicalVolume(SolidWater,m15,"LoGicWater",0,0,0);

LoGicWater->SetVisAttributes(m14);

PhantomLog = new G4LogicalVolume(solidFontome, 	 //its solid
			 m14, 		 //its material
			"PhantomLog" ,		 //its name
			 0,0,0);

 //PhantomLog ->SetVisAttributes(G4VisAttributes::GetInvisible());  
PhantomLog->SetVisAttributes(m2);



G4RotationMatrix rotMatrixpPhantom;   // unit rotation matrix
G4double anglepPhantom =180.0*deg;   // rotational angle
rotMatrixpPhantom.rotateX(anglepPhantom);  // rot matrix
/*PhantomPhys= new G4PVPlacement(G4Transform3D(rotMatrixpPhantom,rotation 
		 G4ThreeVector(0*cm, 0.0*m, 21.25*cm)),
		 "PhantomPhys",   //its name  (2nd constructor)
		 PhantomLog,         //its logical volume 
		 pMere,              //its mother volume 
		 false,                 //no boolean operation 
		 0);   */


pLoGicWater= new G4PVPlacement(G4Transform3D(rotMatrixpPhantom,	//rotation 
		 G4ThreeVector(0*cm, 0*cm, 20.00*cm)),
		 "pLoGicWater",   //its name  (2nd constructor)
		 LoGicWater,         //its logical volume 
				 pMere,              //its mother volume 
		 false,                 //no boolean operation 
		 0);        
   




 G4SDManager* pSDManager = G4SDManager::GetSDMpointer();

//----definition des demi demension le long  x, y, z axis--------------------------
  phantomSizeX =11.25*cm ;
  phantomSizeY =11.25*cm;
  phantomSizeZ = 20*cm;

//---- definition de nombre de voxels le long de trois axes x,y,z------------------
  // chaque voxel à un épaisseur de 0.5 cm 

  numberOfVoxelsAlongX = 45;
  numberOfVoxelsAlongY =45;
  numberOfVoxelsAlongZ = 80;
  if(!phantomSD)
  {

    G4String SdName = "Phantom";
   phantomSD = new PhantomSD(SdName, G4ThreeVector( phantomSizeX, phantomSizeY, phantomSizeZ), numberOfVoxelsAlongX,  numberOfVoxelsAlongY,  numberOfVoxelsAlongZ);

    G4String ROGeometryName = "PhantomROGeometry";
    phantomROGeometry = new PhantomROGeometry(ROGeometryName,
                                phantomSizeX,  
				phantomSizeY, 
				phantomSizeZ,
                                numberOfVoxelsAlongX,
				numberOfVoxelsAlongY,		    
				numberOfVoxelsAlongZ);
    phantomROGeometry -> BuildROGeometry();
    phantomSD -> SetROgeometry(phantomROGeometry);
    pSDManager-> AddNewDetector(phantomSD);
    LoGicWater-> SetSensitiveDetector(phantomSD);


}


 return pMere;
}



